const itemFields = [[{dataquery:'itemFields'}]];
    
var fieldList = itemFields.fieldList,
    prefixes = itemFields.prefixes,
    ignoreEmpty = itemFields.ignoreEmpty;


/*** Unequip Button Actions ***/
on("clicked:unequip_melee", function(eventInfo){
    unequipItem(prefixes.eq_melee);
});

on("clicked:unequip_ranged", function(eventInfo){
    unequipItem(prefixes.eq_ranged);
});

on("clicked:unequip_head", function(eventInfo){
    unequipItem(prefixes.eq_head);
});

on("clicked:unequip_body", function(eventInfo){
    unequipItem(prefixes.eq_body);
});

/*** Equip Button Actions ***/
on("clicked:repeating_inventory:equipmelee", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(prefixes.eq_melee, prefixes.inventory, rowId);
});

on("clicked:repeating_inventory:equipranged", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(prefixes.eq_ranged, prefixes.inventory, rowId);
});

on("clicked:repeating_inventory:equiphead", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(prefixes.eq_head, prefixes.inventory, rowId);
});

on("clicked:repeating_inventory:equipbody", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(prefixes.eq_body, prefixes.inventory, rowId);
});



function equipItem(eqPrefix, invPrefix, rowId){
    var invFields = prefixFields(rowId + "_" + invPrefix, fieldList),
        equippedFields = prefixFields(eqPrefix, fieldList),
        bothFields = invFields.concat(equippedFields);


    getAttrs(bothFields, function(values){
        var equipEmpty = true,
            invEmpty = true;

        /** Validate fields aren't empty **/
        for (let field of invFields) {
            if (!field.endsWith(ignoreEmpty) && values[field].length > 0){ //dont check item type is empty or else empty items never get caught as item type shouldnt be empty
                invEmpty = false;
                break;
            }
        }

        for (let field of equippedFields) {
            if (!field.endsWith(ignoreEmpty) && values[field].length > 0){
                equipEmpty = false;
                break;
            }
        }

        if (invEmpty) { return;} //don't do anything if the item to be equipped is empty.


        /** Do the data transposing */
        var attrSet = {};

        //set the equipped fields from inventory fields
        for (const field of invFields) {
            attrSet[eqPrefix + "_" + field] = values["repeating_inventory_" + field]; 
        }

        //If equipped fields aren't empty, then we can add them back to the inventory
        if (!equipEmpty) {
            for (let field of equippedFields) {
                attrSet["repeating_inventory_" + field] = values[eqPrefix + "_" + field]; 
            }
        }



        //If there is an equipped item, generate an unequip object to append to the equip object
        if (!equipEmpty){
            //Go through each key in the equippedFields array, and find the matching value for that key in the values object.
            var equipValues = equippedFields.reduce((obj,item) => {
                var newObj = {}

                //the first obj is a string. In that case, you should not use the spread operator to accumulate the object
                if (typeof obj === "string") {
                    newObj[obj] = values[obj];
                } else {
                    newObj = {...obj};
                }

                newObj[item] = values[item]; //add new one

                return newObj;
            });

            var unequipObject = createUnequipObject(eqPrefix, invPrefix, equipValues);
        }

    });
}


function unequipItem(prefix){
    var equippedFields = prefixFields(prefix, fieldList);

    getAttrs(equippedFields, function(values){
        //check if every field is empty, and return if it is.
        if (Object.keys(values).every(function(key, element){
            if (key.endsWith(ignoreEmpty)){ return true}; //Item Type edge case - Item Type should never be empty on an equipped item so we have to ignore this one. There's a bug here if you have another field that ends with the same attr_name, but whatever
            return values[key].length == 0; //length check

        })) { return; } 

        var attrSet = createUnequipObject(prefix, prefixes.inventory, values)

        setAttrs(attrSet);
    });
}


function getEquippedObject(prefix, values) {
}



/**
 * Generates an object for unequipping an item, which can be passed directly into setAttrs 
 * @param {string} prefix - The Prefix for an Equipped Item
  * @param {string} invPrefix - The Prefix for an Inventory Item
 * @param {object} values - An object containing field-value mappings, such as one generated by getAttrs
 */
function createUnequipObject(prefix, invPrefix, values) {
    var newInvRowId = generateRowID(),
        attrSet = {};

    //replace the prefix with repeating_{inventory}_{newRowid}
    //the last underscore connecting to attr_name is already in place there with prefixFields
    for (const prop in values){
        let newProp = prop.replace(prefix, "repeating_inventory_" + newInvRowId + "_" + invPrefix);
        attrSet[newProp] = values[prop];
        if (prop)
        attrSet[prop] = ""; //clear current
    }   

    return attrSet;
}


function getButtonRowId(eventInfo){
    var underscoreIndex = eventInfo.sourceAttribute.lastIndexOf("_");
    return eventInfo.sourceAttribute.substr(0, underscoreIndex);
}

function prefixFields(prefix, fieldList){
    return fieldList.map((x)=>{
        return prefix + "_" + x;
    })
}
