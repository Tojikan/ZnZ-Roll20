const itemFields = [[{dataquery:'itemFields'}]];
    
var fieldList = itemFields.fieldList,
    ignoreEmpty = itemFields.ignoreEmpty;


/*** Unequip Button Actions ***/
on("clicked:unequip_melee", function(eventInfo){
    unequipItem(global.meleePrefix);
});

on("clicked:unequip_ranged", function(eventInfo){
    unequipItem(global.rangedPrefix);
});

on("clicked:unequip_head", function(eventInfo){
    unequipItem(global.headPrefix);
});

on("clicked:unequip_body", function(eventInfo){
    unequipItem(global.bodyPrefix);
});

/*** Equip Button Actions ***/
on("clicked:repeating_inventory:equipmelee", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(global.meleePrefix, global.invPrefix, rowId);
});

on("clicked:repeating_inventory:equipranged", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(global.rangedPrefix, global.invPrefix, rowId);
});

on("clicked:repeating_inventory:equiphead", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(global.headPrefix, global.invPrefix, rowId);
});

on("clicked:repeating_inventory:equipbody", function(eventInfo){
    const rowId = getButtonRowId(eventInfo);
    equipItem(global.bodyPrefix, global.invPrefix, rowId);
});



function equipItem(eqPrefix, invPrefix, rowId){
    var invFields = prefixFields(rowId + "_" + invPrefix, fieldList),
        equippedFields = prefixFields(eqPrefix, fieldList),
        bothFields = invFields.concat(equippedFields);


    getAttrs(bothFields, function(values){
        var equipEmpty = true,
            invEmpty = true;

        /** Validate fields aren't empty **/
        for (let field of invFields) {
            if (!field.endsWith(ignoreEmpty) && values[field].length > 0){ //dont check item type is empty or else empty items never get caught as item type shouldnt be empty
                invEmpty = false;
                break;
            }
        }

        for (let field of equippedFields) {
            if (!field.endsWith(ignoreEmpty) && values[field].length > 0){
                equipEmpty = false;
                break;
            }
        }

        if (invEmpty) { return;} //don't do anything if the item to be equipped is empty.


        /** Do the data transposing */
        var attrSet = {};

        //set the equipped fields from inventory fields
        for (const field of fieldList) { //we have to restart back to fieldList now for ease.
            attrSet[eqPrefix + "_" + field] = values[rowId + "_" + invPrefix + "_" + field]; 
        }

        //If equipped fields aren't empty, then we can add equipped back to the inventory
        if (!equipEmpty) {
            for (const field of fieldList) {
                attrSet[rowId + "_" + invPrefix + "_" + field] = values[eqPrefix + "_" + field]; 
            }
        }

        removeRepeatingRow(rowId);
        setAttrs(attrSet);
    });
}


function unequipItem(prefix){
    var equippedFields = prefixFields(prefix, fieldList);

    getAttrs(equippedFields, function(values){
        //check if every field is empty, and return if it is.
        if (Object.keys(values).every(function(key, element){
            if (key.endsWith(ignoreEmpty)){ return true}; //Item Type edge case - Item Type should never be empty on an equipped item so we have to ignore this one. There's a bug here if you have another field that ends with the same attr_name, but whatever
            return values[key].length == 0; //length check

        })) { return; } 

        var attrSet = createUnequipObject(prefix, global.invPrefix, values)

        setAttrs(attrSet);
    });
}




/**
 * Generates an object for unequipping an item, which can be passed directly into setAttrs 
 * @param {string} prefix - The Prefix for an Equipped Item
  * @param {string} invPrefix - The Prefix for an Inventory Item
 * @param {object} values - An object containing field-value mappings, such as one generated by getAttrs
 */
function createUnequipObject(prefix, invPrefix, values) {
    var newInvRowId = generateRowID(),
        attrSet = {};

    //replace the prefix with repeating_{inventory}_{newRowid}
    //the last underscore connecting to attr_name is already in place there with prefixFields
    for (const prop in values){
        let newProp = prop.replace(prefix, "repeating_inventory_" + newInvRowId + "_" + invPrefix);
        attrSet[newProp] = values[prop];
        if (prop)
        attrSet[prop] = ""; //clear current
    }   

    return attrSet;
}


function getButtonRowId(eventInfo){
    var underscoreIndex = eventInfo.sourceAttribute.lastIndexOf("_");
    return eventInfo.sourceAttribute.substr(0, underscoreIndex);
}

function prefixFields(prefix, fieldList){
    return fieldList.map((x)=>{
        return prefix + "_" + x;
    })
}
